#' @import ecospat
NULL
#' Custom version of ecospat's function that allows you to remove NA values.
#'
#' @export
ecospat.grid.clim.dyn_custom <- function(glob, glob1, sp, R, th.sp = 0, th.env = 0,
                                         geomask = NULL,removeNA=T) {
  
  glob <- as.matrix(glob)
  glob1 <- as.matrix(glob1)
  sp <- as.matrix(sp)
  l <- list()
  
  if (ncol(glob) > 2)
    stop("cannot calculate overlap with more than two axes")
  
  if (ncol(glob) == 1) {
    # if scores in one dimension (e.g. LDA,SDM predictions,...)
    xmax <- max(glob[, 1])
    xmin <- min(glob[, 1])
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), length.out = R) # breaks on score gradient 1
    sp.dens <- density(sp[, 1], kernel = "gaussian", from = xmin, to = xmax,
                       n = R, cut = 0) # calculate the density of occurrences in a vector of R pixels along the score gradient
    # using a gaussian kernel density function, with R bins.
    glob1.dens <- density(glob1[, 1], kernel = "gaussian", from = xmin,
                          to = xmax, n = R, cut = 0) # calculate the density of environments in glob1
    z <- sp.dens$y * nrow(sp)/sum(sp.dens$y) # rescale density to the number of occurrences in sp
    # number of occurrence/pixel
    Z <- glob1.dens$y * nrow(glob)/sum(glob1.dens$y) # rescale density to the number of sites in glob1
    glob1r <- sapply(glob1, findInterval, glob1.dens$x)
    th.env <- quantile(glob1.dens$y[glob1r], th.env)
    glob1rm <- which(Z < th.env)
    spr <- sapply(sp, findInterval, sp.dens$x)
    th.sp <- quantile(sp.dens$y[spr], th.sp)
    sprm <- which(z < th.sp)
    z[sprm] <- 0 # remove infinitesimally small number generated by kernel density function
    Z[glob1rm] <- 0 # remove infinitesimally small number generated by kernel density function
    
    z.uncor <- z/max(z) # rescale between [0:1] for comparison with other species
    z.cor <- z/Z # correct for environment prevalence
    z.cor[is.na(z.cor)] <- 0 # remove n/0 situations
    z.cor[z.cor == "Inf"] <- 0 # remove 0/0 situations
    z.cor <- z.cor/max(z.cor) # rescale between [0:1] for comparison with other species
    w <- z.uncor
    w[w > 0] <- 1
    l$x <- x
    l$z <- z
    l$z.uncor <- z.uncor
    l$z.cor <- z.cor
    l$Z <- Z
    l$glob <- glob
    l$glob1 <- glob1
    l$sp <- sp
    l$w <- w
  }
  
  if (ncol(glob) == 2) {
    # if scores in two dimensions (e.g. PCA)
    
    xmin <- min(glob[, 1])
    xmax <- max(glob[, 1])
    ymin <- min(glob[, 2])
    ymax <- max(glob[, 2]) # data preparation
    glob1r <- data.frame(cbind((glob1[, 1] - xmin)/abs(xmax - xmin), (glob1[,
                                                                            2] - ymin)/abs(ymax - ymin))) # data preparation
    spr <- data.frame(cbind((sp[, 1] - xmin)/abs(xmax - xmin), (sp[, 2] -
                                                                  ymin)/abs(ymax - ymin))) # data preparation
    mask <- adehabitatMA::ascgen(sp::SpatialPoints(cbind((0:(R))/R, (0:(R)/R))),
                                 nrcol = R-2, count = FALSE) # data preparation
    sp.dens <- adehabitatHR::kernelUD(sp::SpatialPoints(spr[, 1:2]), h = "href", grid = mask,
                                      kern = "bivnorm") # calculate the density of occurrences in a grid of RxR pixels along the score gradients
    sp.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, ymx = ymax, matrix(sp.dens$ud,
                                                                             nrow = R))
    # using a gaussian kernel density function, with RxR bins.
    # sp.dens$var[sp.dens$var>0 & sp.dens$var<1]<-0
    glob1.dens <- adehabitatHR::kernelUD(sp::SpatialPoints(glob1r[, 1:2]), grid = mask, kern = "bivnorm")
    glob1.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, ymx = ymax,
                         matrix(glob1.dens$ud, nrow = R))
    # glob1.dens$var[glob1.dens$var<1 & glob1.dens$var>0]<-0
    
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), length.out = R) # breaks on score gradient 1
    y <- seq(from = min(glob[, 2]), to = max(glob[, 2]), length.out = R) # breaks on score gradient 2
    glob1r <- extract(glob1.dens, glob1)
    Z.th <- quantile(glob1r, th.env,na.rm=removeNA)
    glob1.dens[glob1.dens < Z.th] <- 0
    if (!is.null(geomask)) {
      proj4string(geomask) <- NA
      glob1.dens <- mask(glob1.dens, geomask, updatevalue = 0) # Geographical mask in the case if the analysis takes place in the geographical space
    }
    Z <- glob1.dens * nrow(glob1)/cellStats(glob1.dens, "sum")
    
    spr <- extract(sp.dens, sp)
    z.th <- quantile(spr, th.sp)
    sp.dens[Z == 0] <- 0
    sp.dens[sp.dens < z.th] <- 0
    if (!is.null(geomask)) {
      sp.dens <- mask(sp.dens, geomask, updatevalue = 0) # Geographical mask in the case if the analysis takes place in the geographical space
    }
    z <- sp.dens * nrow(sp)/cellStats(sp.dens, "sum")
    z.uncor <- z/cellStats(z, "max")
    w <- z.uncor # remove infinitesimally small number generated by kernel density function
    w[w > 0] <- 1
    z.cor <- z/Z # correct for environment prevalence
    z.cor[is.na(z.cor)] <- 0 # remove n/0 situations
    z.cor <- z.cor/cellStats(z.cor, "max")
    l$x <- x
    l$y <- y
    l$z <- z
    l$z.uncor <- z.uncor
    l$z.cor <- z.cor
    l$Z <- Z
    l$glob <- glob
    l$glob1 <- glob1
    l$sp <- sp
    l$w <- w
    
  }
  
  return(l)
}
#' @import ecospat
NULL
#' Custom version of ecospat's niche equivalency testing
#'
#' @export
ecospat.niche.equivalency.test_custom <- 
  function (z1, z2, rep, intersection = 0, overlap.alternative = "higher", 
            expansion.alternative = "lower", stability.alternative = "higher", 
            unfilling.alternative = "lower", ncores = 1) 
  {
    if (isFALSE(overlap.alternative %in% c("higher", "lower", 
                                           "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the overlap")
    }
    if (isFALSE(expansion.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the expansion")
    }
    if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the stability")
    }
    if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the unfilling")
    }
    R <- length(z1$x)
    l <- list()
    step1 <- ecospat.niche.overlap(z1, z2, cor = TRUE)
    step2 <- ecospat.niche.dyn.index_custom(z1, z2, intersection=0)
    obs.o <- c(step1, step2$dynamic.index.w)
    if (ncores == 1) {
      sim.o <- as.data.frame(matrix(unlist(lapply(1:rep, ecospat:::overlap.eq.gen, 
                                                  z1, z2, intersection = intersection)), byrow = TRUE, 
                                    ncol = 5))
    }
    else {
      cl <- parallel::makeCluster(ncores)
      invisible(parallel::clusterEvalQ(cl, library("ecospat")))
      sim.o <- as.data.frame(matrix(unlist(parallel::parLapply(cl, 
                                                               1:rep, ecospat:::overlap.eq.gen, z1, z2, intersection = intersection)), 
                                    byrow = TRUE, ncol = 5))
      parallel::stopCluster(cl)
    }
    colnames(sim.o) <- c("D", "I", "expansion", "stability", 
                         "unfilling")
    l$sim <- sim.o
    l$obs <- obs.o
    l$p.D <- p.val.gen(sim.o$D, obs.o$D, overlap.alternative)
    l$p.I <- p.val.gen(sim.o$I, obs.o$I, overlap.alternative)
    l$p.expansion <- p.val.gen(sim.o$expansion, obs.o$expansion, 
                               expansion.alternative)
    l$p.stability <- p.val.gen(sim.o$stability, obs.o$stability, 
                               stability.alternative)
    l$p.unfilling <- p.val.gen(sim.o$unfilling, obs.o$unfilling, 
                               unfilling.alternative)
    return(l)
  }
#' @import ecospat
NULL
#' Custom version of ecospat's niche dynamics testing
#'
#' @export
ecospat.niche.dyn.index_custom <- function (z1, z2, intersection = 0) 
{
  w1.full <- as.matrix(z1$w)
  w2.full <- as.matrix(z2$w)
  glob1 <- as.matrix(z1$Z)
  glob2 <- as.matrix(z2$Z)
  if (intersection > 0) {
    quant.val.z1 <- quantile(glob1[glob1 > 0], probs = seq(0, 
                                                           1, intersection))[2]
    quant.val.z2 <- quantile(glob2[glob2 > 0], probs = seq(0, 
                                                           1, intersection))[2]
  }
  if (intersection == 0) {
    quant.val.z1 <- 0
    quant.val.z2 <- 0
  }
  glob <- (glob1 > quant.val.z1) * (glob2 > quant.val.z2)
  w1 <- w1.full * glob
  w2 <- w2.full * glob
  z.pio.cat <- (((glob2 > quant.val.z2) - (glob1 > quant.val.z1)) == 
                  1) * (w2.full * (glob2 > quant.val.z2))
  z.exp.cat <- 1 * (((w1 + 2 * w2)/2) == 1)
  z.stable.cat <- 1 * ((w1 + 2 * w2) == 3)
  z.unf.cat <- 1 * ((w1 + 2 * w2) == 1)
  z.abn.cat <- (((glob1 > quant.val.z1) - (glob2 > quant.val.z2)) == 
                  1) * (w1.full * (glob1 > quant.val.z1))
  z.na.cat <- ((w1.full + w2.full) > 0) - ((z.pio.cat + z.exp.cat + 
                                              z.stable.cat + z.unf.cat + z.abn.cat) > 0)
  obs.pio <- as.matrix(z2$z.uncor) * as.matrix(z.pio.cat)
  obs.exp <- as.matrix(z2$z.uncor) * as.matrix(z.exp.cat)
  obs.stab <- as.matrix(z2$z.uncor) * as.matrix(z.stable.cat)
  obs.unf <- as.matrix(z1$z.uncor) * as.matrix(z.unf.cat)
  obs.abn <- as.matrix(z1$z.uncor) * as.matrix(z.abn.cat)
  dyn <- z.abn.cat + (2 * z.unf.cat) + (3 * z.stable.cat) + 
    (4 * z.exp.cat) + (5 * z.pio.cat)
  dyn[z.na.cat[] == 1] <- 6
  if (!is.null(z1$y)) {
    dyn <- terra::rast(matrix(dyn, nrow = dim(z1$w)[1], ncol = dim(z1$w)[2], 
                              byrow = TRUE))
    terra::ext(dyn) <- terra::ext(c(min(z2$x), max(z2$x), 
                                    min(z2$y), max(z2$y)))
  }
  expansion.index.w <- sum(obs.exp)/sum(obs.stab + obs.exp)
  stability.index.w <- sum(obs.stab)/sum(obs.stab + obs.exp)
  unfilling.index.w <- sum(obs.unf)/sum(obs.unf + (z.stable.cat * 
                                                     as.matrix(z1$z.uncor)))
  expansion.index.w[is.nan(expansion.index.w)] <- 0
  stability.index.w[is.nan(stability.index.w)] <- 0
  unfilling.index.w[is.nan(unfilling.index.w)] <- 0
  z2_only_NA <- sum(obs.pio)
  z2_only_A <- sum(obs.exp)
  z2_z1 <- sum(obs.stab)
  z1_only_NA <- sum(obs.abn)
  z1_only_A <- sum(obs.unf)
  z1_z2 <- sum(as.matrix(z1$z.uncor) * as.matrix(z.stable.cat))
  part <- list()
  part$dyn <- dyn
  part$dynamic.index.w <- c(expansion.index.w, stability.index.w, 
                            unfilling.index.w)
  names(part$dynamic.index.w) <- c("expansion", "stability", 
                                   "unfilling")
  part$category_quantity <- c(z2_only_NA, z2_only_A, z2_z1, 
                              z1_only_NA, z1_only_A, z1_z2)
  names(part$category_quantity) <- c("z2_only_NA", "z2_only_A", 
                                     "z2_z1", "z1_only_NA", "z1_only_A", "z1_z2")
  return(part)
}



#' @import ecospat
NULL
#' Custom version of ecospat's function that allows you to remove NA values.
#'
#' @export
ecospat.grid.clim.dyn_custom <- function(glob, glob1, sp, R, th.sp = 0, th.env = 0,
                                         geomask = NULL,removeNA=T) {
  
  glob <- as.matrix(glob)
  glob1 <- as.matrix(glob1)
  sp <- as.matrix(sp)
  l <- list()
  
  if (ncol(glob) > 2)
    stop("cannot calculate overlap with more than two axes")
  
  if (ncol(glob) == 1) {
    # if scores in one dimension (e.g. LDA,SDM predictions,...)
    xmax <- max(glob[, 1])
    xmin <- min(glob[, 1])
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), length.out = R) # breaks on score gradient 1
    sp.dens <- density(sp[, 1], kernel = "gaussian", from = xmin, to = xmax,
                       n = R, cut = 0) # calculate the density of occurrences in a vector of R pixels along the score gradient
    # using a gaussian kernel density function, with R bins.
    glob1.dens <- density(glob1[, 1], kernel = "gaussian", from = xmin,
                          to = xmax, n = R, cut = 0) # calculate the density of environments in glob1
    z <- sp.dens$y * nrow(sp)/sum(sp.dens$y) # rescale density to the number of occurrences in sp
    # number of occurrence/pixel
    Z <- glob1.dens$y * nrow(glob)/sum(glob1.dens$y) # rescale density to the number of sites in glob1
    glob1r <- sapply(glob1, findInterval, glob1.dens$x)
    th.env <- quantile(glob1.dens$y[glob1r], th.env)
    glob1rm <- which(Z < th.env)
    spr <- sapply(sp, findInterval, sp.dens$x)
    th.sp <- quantile(sp.dens$y[spr], th.sp)
    sprm <- which(z < th.sp)
    z[sprm] <- 0 # remove infinitesimally small number generated by kernel density function
    Z[glob1rm] <- 0 # remove infinitesimally small number generated by kernel density function
    
    z.uncor <- z/max(z) # rescale between [0:1] for comparison with other species
    z.cor <- z/Z # correct for environment prevalence
    z.cor[is.na(z.cor)] <- 0 # remove n/0 situations
    z.cor[z.cor == "Inf"] <- 0 # remove 0/0 situations
    z.cor <- z.cor/max(z.cor) # rescale between [0:1] for comparison with other species
    w <- z.uncor
    w[w > 0] <- 1
    l$x <- x
    l$z <- z
    l$z.uncor <- z.uncor
    l$z.cor <- z.cor
    l$Z <- Z
    l$glob <- glob
    l$glob1 <- glob1
    l$sp <- sp
    l$w <- w
  }
  
  if (ncol(glob) == 2) {
    # if scores in two dimensions (e.g. PCA)
    xmin <- min(glob[, 1])
    xmax <- max(glob[, 1])
    ymin <- min(glob[, 2])
    ymax <- max(glob[, 2]) # data preparation
    glob1r <- data.frame(cbind((glob1[, 1] - xmin)/abs(xmax - xmin), (glob1[,
                                                                            2] - ymin)/abs(ymax - ymin))) # data preparation
    spr <- data.frame(cbind((sp[, 1] - xmin)/abs(xmax - xmin), (sp[, 2] -
                                                                  ymin)/abs(ymax - ymin))) # data preparation
    mask <- adehabitatMA::ascgen(sp::SpatialPoints(cbind((0:(R))/R, (0:(R)/R))),
                                 nrcol = R-2, count = FALSE) # data preparation
    sp.dens <- adehabitatHR::kernelUD(sp::SpatialPoints(spr[, 1:2]), h = "href", grid = mask,
                                      kern = "bivnorm") # calculate the density of occurrences in a grid of RxR pixels along the score gradients
    sp.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, ymx = ymax, matrix(sp.dens$ud,
                                                                             nrow = R))

    # using a gaussian kernel density function, with RxR bins.
    # sp.dens$var[sp.dens$var>0 & sp.dens$var<1]<-0
    glob1.dens <- adehabitatHR::kernelUD(sp::SpatialPoints(glob1r[, 1:2]), grid = mask, kern = "bivnorm")
    glob1.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, ymx = ymax,
                         matrix(glob1.dens$ud, nrow = R))
    # glob1.dens$var[glob1.dens$var<1 & glob1.dens$var>0]<-0
    
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), length.out = R) # breaks on score gradient 1
    y <- seq(from = min(glob[, 2]), to = max(glob[, 2]), length.out = R) # breaks on score gradient 2
    glob1r <- extract(glob1.dens, glob1)
    Z.th <- quantile(glob1r, th.env,na.rm=removeNA)
    glob1.dens[glob1.dens < Z.th] <- 0

    if (!is.null(geomask)) {
      proj4string(geomask) <- NA
      glob1.dens <- mask(glob1.dens, geomask, updatevalue = 0) # Geographical mask in the case if the analysis takes place in the geographical space
    }
    Z <- glob1.dens * nrow(glob1)/cellStats(glob1.dens, "sum")
    
    spr <- extract(sp.dens, sp)
    z.th <- quantile(spr, th.sp)
    sp.dens[Z == 0] <- 0
    sp.dens[sp.dens < z.th] <- 0
    if (!is.null(geomask)) {
      sp.dens <- mask(sp.dens, geomask, updatevalue = 0) # Geographical mask in the case if the analysis takes place in the geographical space
    }

    z <- sp.dens * nrow(sp)/cellStats(sp.dens, "sum")
    z.uncor <- z/cellStats(z, "max")
    w <- z.uncor # remove infinitesimally small number generated by kernel density function
    w[w > 0] <- 1
    z.cor <- z/Z # correct for environment prevalence
    z.cor[is.na(z.cor)] <- 0 # remove n/0 situations
    z.cor <- z.cor/cellStats(z.cor, "max")

    l$x <- x
    l$y <- y
    l$z <- z
    l$z.uncor <- z.uncor
    l$z.cor <- z.cor
    l$Z <- Z
    l$glob <- glob
    l$glob1 <- glob1
    l$sp <- sp
    l$w <- w
    
  }
  
  return(l)
}
#' @import ecospat
NULL
#' Custom version of ecospat's niche equivalency testing
#'
#' @export
ecospat.niche.equivalency.test_custom <- 
  function (z1, z2, rep, intersection = 0, overlap.alternative = "higher", 
            expansion.alternative = "lower", stability.alternative = "higher", 
            unfilling.alternative = "lower", ncores = 1) 
  {
    if (isFALSE(overlap.alternative %in% c("higher", "lower", 
                                           "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the overlap")
    }
    if (isFALSE(expansion.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the expansion")
    }
    if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the stability")
    }
    if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                             "different"))) {
      stop("Please choose an alternative hypothesis (higher,lower or diffrent) for the unfilling")
    }
    R <- length(z1$x)
    l <- list()
    step1 <- ecospat.niche.overlap(z1, z2, cor = TRUE)
    step2 <- ecospat.niche.dyn.index_custom(z1, z2, intersection=0)
    obs.o <- c(step1, step2$dynamic.index.w)
    print("starting overlap.eq.gen_custom")
    
    if (ncores == 1) {
      sim.o <- as.data.frame(matrix(unlist(lapply(1:rep, overlap.eq.gen_custom, 
                                                  z1, z2, intersection = intersection)), byrow = TRUE, 
                                    ncol = 5))
    }
    else {
      cl <- parallel::makeCluster(ncores)
      invisible(parallel::clusterEvalQ(cl, library("ecospat")))
      sim.o <- as.data.frame(matrix(unlist(parallel::parLapply(cl, 
                                                               1:rep, overlap.eq.gen_custom, z1, z2, intersection = intersection)), 
                                    byrow = TRUE, ncol = 5))
      parallel::stopCluster(cl)
    }
    colnames(sim.o) <- c("D", "I", "expansion", "stability", 
                         "unfilling")
    l$sim <- sim.o
    l$obs <- obs.o
    l$p.D <- ecospat:::p.val.gen(sim.o$D, obs.o$D, overlap.alternative)
    l$p.I <- ecospat:::p.val.gen(sim.o$I, obs.o$I, overlap.alternative)
    l$p.expansion <- ecospat:::p.val.gen(sim.o$expansion, obs.o$expansion, 
                               expansion.alternative)
    l$p.stability <- ecospat:::p.val.gen(sim.o$stability, obs.o$stability, 
                               stability.alternative)
    l$p.unfilling <- ecospat:::p.val.gen(sim.o$unfilling, obs.o$unfilling, 
                               unfilling.alternative)
    return(l)
  }
#' @import ecospat
NULL
#' Custom version of ecospat's niche dynamics testing
#'
#' @export
ecospat.niche.dyn.index_custom <- function (z1, z2, intersection = 0) 
{
  w1.full <- as.matrix(z1$w)
  w2.full <- as.matrix(z2$w)
  glob1 <- as.matrix(z1$Z)
  glob2 <- as.matrix(z2$Z)
  if (intersection > 0) {
    quant.val.z1 <- quantile(glob1[glob1 > 0], probs = seq(0, 
                                                           1, intersection))[2]
    quant.val.z2 <- quantile(glob2[glob2 > 0], probs = seq(0, 
                                                           1, intersection))[2]
  }
  if (intersection == 0) {
    quant.val.z1 <- 0
    quant.val.z2 <- 0
  }
  glob <- (glob1 > quant.val.z1) * (glob2 > quant.val.z2)
  w1 <- w1.full * glob
  w2 <- w2.full * glob
  z.pio.cat <- (((glob2 > quant.val.z2) - (glob1 > quant.val.z1)) == 
                  1) * (w2.full * (glob2 > quant.val.z2))
  z.exp.cat <- 1 * (((w1 + 2 * w2)/2) == 1)
  z.stable.cat <- 1 * ((w1 + 2 * w2) == 3)
  z.unf.cat <- 1 * ((w1 + 2 * w2) == 1)
  z.abn.cat <- (((glob1 > quant.val.z1) - (glob2 > quant.val.z2)) == 
                  1) * (w1.full * (glob1 > quant.val.z1))
  z.na.cat <- ((w1.full + w2.full) > 0) - ((z.pio.cat + z.exp.cat + 
                                              z.stable.cat + z.unf.cat + z.abn.cat) > 0)
  obs.pio <- as.matrix(z2$z.uncor) * as.matrix(z.pio.cat)
  obs.exp <- as.matrix(z2$z.uncor) * as.matrix(z.exp.cat)
  obs.stab <- as.matrix(z2$z.uncor) * as.matrix(z.stable.cat)
  obs.unf <- as.matrix(z1$z.uncor) * as.matrix(z.unf.cat)
  obs.abn <- as.matrix(z1$z.uncor) * as.matrix(z.abn.cat)
  dyn <- z.abn.cat + (2 * z.unf.cat) + (3 * z.stable.cat) + 
    (4 * z.exp.cat) + (5 * z.pio.cat)
  dyn[z.na.cat[] == 1] <- 6
  if (!is.null(z1$y)) {
    dyn <- terra::rast(matrix(dyn, nrow = dim(z1$w)[1], ncol = dim(z1$w)[2], 
                              byrow = TRUE))
    terra::ext(dyn) <- terra::ext(c(min(z2$x), max(z2$x), 
                                    min(z2$y), max(z2$y)))
  }
  expansion.index.w <- sum(obs.exp)/sum(obs.stab + obs.exp)
  stability.index.w <- sum(obs.stab)/sum(obs.stab + obs.exp)
  unfilling.index.w <- sum(obs.unf)/sum(obs.unf + (z.stable.cat * 
                                                     as.matrix(z1$z.uncor)))
  expansion.index.w[is.nan(expansion.index.w)] <- 0
  stability.index.w[is.nan(stability.index.w)] <- 0
  unfilling.index.w[is.nan(unfilling.index.w)] <- 0
  z2_only_NA <- sum(obs.pio)
  z2_only_A <- sum(obs.exp)
  z2_z1 <- sum(obs.stab)
  z1_only_NA <- sum(obs.abn)
  z1_only_A <- sum(obs.unf)
  z1_z2 <- sum(as.matrix(z1$z.uncor) * as.matrix(z.stable.cat))
  part <- list()
  part$dyn <- dyn
  part$dynamic.index.w <- c(expansion.index.w, stability.index.w, 
                            unfilling.index.w)
  names(part$dynamic.index.w) <- c("expansion", "stability", 
                                   "unfilling")
  part$category_quantity <- c(z2_only_NA, z2_only_A, z2_z1, 
                              z1_only_NA, z1_only_A, z1_z2)
  names(part$category_quantity) <- c("z2_only_NA", "z2_only_A", 
                                     "z2_z1", "z1_only_NA", "z1_only_A", "z1_z2")
  return(part)
}
#' @import ecospat
NULL
#' Custom version of ecospat's overlap equivalency that can handle NA values
#'
#' @export
overlap.eq.gen_custom <- function (repi, z1, z2, intersection = 0) 
{
  if (is.null(z1$y)) {
    occ.pool <- c(z1$sp, z2$sp)
    rand.row <- sample(1:length(occ.pool), length(z1$sp))
    sp1.sim <- occ.pool[rand.row]
    sp2.sim <- occ.pool[-rand.row]
  }
  if (!is.null(z1$y)) {
    occ.pool <- rbind(z1$sp, z2$sp)
    row.names(occ.pool) <- c()
    rand.row <- sample(1:nrow(occ.pool), nrow(z1$sp))
    sp1.sim <- occ.pool[rand.row, ]
    sp2.sim <- occ.pool[-rand.row, ]
  }
  #print("runningecospat.grid.clim.dyn_custom within overlap")
  #print(class(z1$glob))
  #print(class(z1$glob1))
  #print(class(sp1.sim))
  z1.sim <- ecospat.grid.clim.dyn_custom(glob=data.frame(z1$glob), glob1=data.frame(z1$glob1), sp=data.frame(sp1.sim), 
                                  R = length(z1$x))
  z2.sim <- ecospat.grid.clim.dyn_custom(data.frame(z2$glob), data.frame(z2$glob1), data.frame(sp2.sim), 
                                  R = length(z2$x))
  o.i <- ecospat.niche.overlap(z1.sim, z2.sim, cor = TRUE)
  sim.dyn <- ecospat.niche.dyn.index_custom(z1.sim, z2.sim, intersection = 0)$dynamic.index.w
  sim.o.D <- o.i$D
  sim.o.I <- o.i$I
  sim.exp <- sim.dyn[1]
  sim.sta <- sim.dyn[2]
  sim.unf <- sim.dyn[3]
  return(c(sim.o.D, sim.o.I, sim.exp, sim.sta, sim.unf))
}
#' @import ecospat
NULL
#' Custom version of ecospat's niche similarity that can handle NA values
#'
#' @export
ecospat.niche.similarity.test_custom <-
function (z1, z2, rep, intersection = 0, rand.type = 1, ncores = 1, 
          overlap.alternative = "higher", expansion.alternative = "lower", 
          stability.alternative = "higher", unfilling.alternative = "lower") 
{
  if (isFALSE(overlap.alternative %in% c("higher", "lower", 
                                         "different"))) {
    stop("Please choose an alternative hypothesis (higher,lower or different) for the overlap")
  }
  if (isFALSE(expansion.alternative %in% c("higher", "lower", 
                                           "different"))) {
    stop("Please choose an alternative hypothesis (higher,lower or different) for the expansion")
  }
  if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                           "different"))) {
    stop("Please choose an alternative hypothesis (higher,lower or difefrent) for the stability")
  }
  if (isFALSE(stability.alternative %in% c("higher", "lower", 
                                           "different"))) {
    stop("Please choose an alternative hypothesis (higher,lower or different) for the unfilling")
  }
  R <- length(z1$x)
  l <- list()
  
  step1 <- ecospat.niche.overlap(z1, z2, cor = TRUE)
  step2 <- ecospat.niche.dyn.index_custom(z1,z2, intersection)
  obs.o <- c(step1, step2$dynamic.index.w)

  z1$z.uncor <- as.matrix(z1$z.uncor, wide = TRUE)
  z1$z.cor <- as.matrix(z1$z.cor, wide = TRUE)
  z1$Z <- as.matrix(z1$Z, wide = TRUE)
  z1$z <- as.matrix(z1$z, wide = TRUE)
  z2$z.uncor <- as.matrix(z2$z.uncor, wide = TRUE)
  z2$z.cor <- as.matrix(z2$z.cor, wide = TRUE)
  z2$Z <- as.matrix(z2$Z, wide = TRUE)
  z2$z <- as.matrix(z2$z, wide = TRUE)
  if (ncores == 1) {
    sim.o <- as.data.frame(matrix(unlist(lapply(1:rep, overlap.sim.gen_custom, 
                                                z1, z2, rand.type = rand.type)), byrow = TRUE, ncol = 5))
  }
  else {
    cl <- parallel::makeCluster(ncores)
    invisible(parallel::clusterEvalQ(cl, library("ecospat")))
    sim.o <- as.data.frame(matrix(unlist(parallel::parLapply(cl, 
                                                             1:rep, overlap.sim.gen_custom, z1, z2, rand.type = rand.type)), 
                                  byrow = TRUE, ncol = 5))
    parallel::stopCluster(cl)
  }
  colnames(sim.o) <- c("D", "I", "expansion", "stability", 
                       "unfilling")
  l$sim <- sim.o
  l$obs <- obs.o
  l$p.D <- ecospat:::p.val.gen(sim.o$D, obs.o$D, overlap.alternative)
  l$p.I <- ecospat:::p.val.gen(sim.o$I, obs.o$I, overlap.alternative)
  l$p.expansion <- ecospat:::p.val.gen(sim.o$expansion, obs.o$expansion, 
                             expansion.alternative)
  l$p.stability <- ecospat:::p.val.gen(sim.o$stability, obs.o$stability, 
                             stability.alternative)
  l$p.unfilling <- ecospat:::p.val.gen(sim.o$unfilling, obs.o$unfilling, 
                             unfilling.alternative)
  return(l)
}
#' @import ecospat
NULL
#' Custom version of ecospat's overlap similarity that can handle NA values
#'
#' @export
overlap.sim.gen_custom <- 
function (repi, z1, z2, rand.type = rand.type, intersection = 0) 
{
  R1 <- length(z1$x)
  R2 <- length(z2$x)
  if (is.null(z1$y) & is.null(z2$y)) {
    if (rand.type == 1) {
      center.z1 <- which(z1$z.uncor == 1)
      Z1 <- z1$Z/max(z1$Z)
      rand.center.z1 <- sample(1:R1, size = 1, replace = FALSE, 
                               prob = Z1)
      xshift.z1 <- rand.center.z1 - center.z1
      z1.sim <- z1
      z1.sim$z <- rep(0, R1)
      for (i in 1:length(z1$x)) {
        i.trans.z1 <- i + xshift.z1
        if (i.trans.z1 > R1 | i.trans.z1 < 0) 
          (next)()
        z1.sim$z[i.trans.z1] <- z1$z[i]
      }
      z1.sim$z <- (z1$Z != 0) * 1 * z1.sim$z
      z1.sim$z.cor <- (z1.sim$z/z1$Z)/max((z1.sim$z/z1$Z), 
                                          na.rm = TRUE)
      z1.sim$z.cor[which(is.na(z1.sim$z.cor))] <- 0
      z1.sim$z.uncor <- z1.sim$z/max(z1.sim$z, na.rm = TRUE)
      z1.sim$z.uncor[which(is.na(z1.sim$z.uncor))] <- 0
      z1.sim$w <- (z1.sim$z.uncor > 0) * 1
    }
    center.z2 <- which(z2$z.uncor == 1)
    Z2 <- z2$Z/max(z2$Z)
    rand.center.z2 <- sample(1:R2, size = 1, replace = FALSE, 
                             prob = Z2)
    xshift.z2 <- rand.center.z2 - center.z2
    z2.sim <- z2
    z2.sim$z <- rep(0, R2)
    for (i in 1:length(z2$x)) {
      i.trans.z2 <- i + xshift.z2
      if (i.trans.z2 > R2 | i.trans.z2 < 0) 
        (next)()
      z2.sim$z[i.trans.z2] <- z2$z[i]
    }
    z2.sim$z <- (z2$Z != 0) * 1 * z2.sim$z
    z2.sim$z.cor <- (z2.sim$z/z2$Z)/max((z2.sim$z/z2$Z), 
                                        na.rm = TRUE)
    z2.sim$z.cor[which(is.na(z2.sim$z.cor))] <- 0
    z2.sim$z.uncor <- z2.sim$z/max(z2.sim$z, na.rm = TRUE)
    z2.sim$z.uncor[which(is.na(z2.sim$z.uncor))] <- 0
    z2.sim$w <- (z2.sim$z.uncor > 0) * 1
  }
  if (!is.null(z2$y) & !is.null(z1$y)) {
    if (rand.type == 1) {
      centroid.z1 <- which(z1$z.uncor == 1, arr.ind = TRUE)[1, 
      ]
      Z1 <- z1$Z/max(z1$Z)
      rand.centroids.z1 <- which(Z1 > 0, arr.ind = TRUE)
      weight.z1 <- Z1[Z1 > 0]
      rand.centroid.z1 <- rand.centroids.z1[sample(1:nrow(rand.centroids.z1), 
                                                   size = 1, replace = FALSE, prob = weight.z1), 
      ]
      xshift.z1 <- rand.centroid.z1[1] - centroid.z1[1]
      yshift.z1 <- rand.centroid.z1[2] - centroid.z1[2]
      z1.sim <- z1
      z1.sim$z <- matrix(rep(0, R1 * R1), ncol = R1, nrow = R1)
      for (i in 1:R1) {
        for (j in 1:R1) {
          i.trans.z1 <- i + xshift.z1
          j.trans.z1 <- j + yshift.z1
          if (i.trans.z1 > R1 | i.trans.z1 < 0 | j.trans.z1 > 
              R1 | j.trans.z1 < 0) 
            (next)()
          z1.sim$z[i.trans.z1, j.trans.z1] <- z1$z[i, 
                                                   j]
        }
      }
      z1.sim$z <- (z1$Z != 0) * 1 * z1.sim$z
      z1.sim$z.cor <- (z1.sim$z/z1$Z)/max((z1.sim$z/z1$Z), 
                                          na.rm = TRUE)
      z1.sim$z.cor[which(is.na(z1.sim$z.cor))] <- 0
      z1.sim$z.uncor <- z1.sim$z/max(z1.sim$z, na.rm = TRUE)
      z1.sim$z.uncor[which(is.na(z1.sim$z.uncor))] <- 0
      z1.sim$w <- (z1.sim$z.uncor > 0) * 1
    }
    centroid.z2 <- which(z2$z.uncor == 1, arr.ind = TRUE)[1, 
    ]
    Z2 <- z2$Z/max(z2$Z)
    rand.centroids.z2 <- which(Z2 > 0, arr.ind = TRUE)
    weight.z2 <- Z2[Z2 > 0]
    rand.centroid.z2 <- rand.centroids.z2[sample(1:nrow(rand.centroids.z2), 
                                                 size = 1, replace = FALSE, prob = weight.z2), ]
    xshift.z2 <- rand.centroid.z2[1] - centroid.z2[1]
    yshift.z2 <- rand.centroid.z2[2] - centroid.z2[2]
    z2.sim <- z2
    z2.sim$z <- matrix(rep(0, R2 * R2), ncol = R2, nrow = R2)
    for (i in 1:R2) {
      for (j in 1:R2) {
        i.trans.z2 <- i + xshift.z2
        j.trans.z2 <- j + yshift.z2
        if (i.trans.z2 > R2 | i.trans.z2 < 0 | j.trans.z2 > 
            R2 | j.trans.z2 < 0) 
          (next)()
        z2.sim$z[i.trans.z2, j.trans.z2] <- z2$z[i, j]
      }
    }
    z2.sim$z <- (z2$Z != 0) * 1 * z2.sim$z
    z2.sim$z.cor <- (z2.sim$z/z2$Z)/max((z2.sim$z/z2$Z), 
                                        na.rm = TRUE)
    z2.sim$z.cor[which(is.na(z2.sim$z.cor))] <- 0
    z2.sim$z.uncor <- z2.sim$z/max(z2.sim$z, na.rm = TRUE)
    z2.sim$z.uncor[which(is.na(z2.sim$z.uncor))] <- 0
    z2.sim$w <- (z2.sim$z.uncor > 0) * 1
  }
  if (rand.type == 1) {
    o.i <- ecospat.niche.overlap(z1.sim, z2.sim, cor = TRUE)
    sim.dyn <- ecospat.niche.dyn.index_custom(z1.sim, z2.sim, intersection)$dynamic.index.w
  }
  if (rand.type == 2) {
    o.i <- ecospat.niche.overlap(z1, z2.sim, cor = TRUE)
    z1$w <- as.matrix(z1$w, wide = TRUE)
    sim.dyn <- ecospat.niche.dyn.index_custom(z1, z2.sim, intersection)$dynamic.index.w
  }
  sim.o.D <- o.i$D
  sim.o.I <- o.i$I
  sim.exp <- sim.dyn[1]
  sim.sta <- sim.dyn[2]
  sim.unf <- sim.dyn[3]
  return(c(sim.o.D, sim.o.I, sim.exp, sim.sta, sim.unf))
}
